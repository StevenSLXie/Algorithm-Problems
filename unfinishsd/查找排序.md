查找排序一锅端
==========================
查找(searching)和排序(sorting)是算法的大头，这当中的大部分内容理解起来不难，但真要动手写起来总有这样那样的细节问题。而且感觉除非经常和算法打交道，否则过段时间就很容易忘记（起码我是这样，已是第N次回顾某排序算法了），所以这里先挖个坑，通过例子把要点总结起来。既希望是一个实践性比较强的教程，也是自己的一个备忘录。

这篇笔记会用Python，原因有几个。一来自己习惯Python，二来Python天生好懂，三来这里有个在线的Python解释器：http://repl.it/languages/Python/ 可以零安装零配置零折腾地开始写Python，方便到令人发指。

Python由于太过方便，本身自带了很多查找和排序的功能，所以这个例程会适时地禁用某些东西（比如，总不能直接调用sort()来写一个快速排序吧）。这些会在各个例子里注明，也因此会使得一些代码看起来不那么Pythonic或者解法是sub-optimal。

按照我的其它笔记的模式，从几个例子开始讲起，从最简单的开始说。谨慎建议对于下面的例子，无论看起来多简单，或者用Python，或者用上你熟悉的语言，动手自己写一下，相信会有不一样的发现。

<h4>1. 顺序查找</h4>

**例1** 给定一个整数s和一个整数数组a，判断s是否在a中。（注：不能用Python自带的`if s in a`）

```python
def seq_search(s, a):
    for i in range(len(a)):
        if s == a[i]:
            return True
    return False
```
给几个测试例子
```python
a = [13,42,3,4,7,5,6]
s = 7
print seq_search(s,a)

a2 = [10,25,3,4,780,5,6]
s = 70
print seq_search(s,a)
```

如无意外的话，会输出：
```python
True
False
```

这个例子异常简单，无非是遍历一个数组，看能不能找到s,找到了就停止搜索，并返回真，如果转了一圈没结果，就返回假。如果要算它的复杂度也简单，各种情况下，复杂度是这样的：


| 情况 | 最好 | 最坏 | 平均 |
| :-----: |:--------:| :-----:| :---:|
| 找到了 | 1 | n | n/2 |
| 没找到 | n | n | n |

用`Big-O`来表示，就是复杂度是`O(n)`。对于没找到的情况，数组总是要遍历一次的。而对于元素在数组中的情况，则要分运气好坏，或许第一个就中了，或许最后一个才是。

**例2**注册网站账号时，用户名常常要符合某些要求，比如不能含有英文的';!~'这三个字符。写一个函数，读入用户输出的用户名，返回“用户名合法”或者“用户名不合法”。

一个直观的解法是这样：

```python
def username_check():
    username = input('输入一个用户名')
    
    for s in ';!~':
        if seq_search(s,username):
           return '用户名不合法'
    return '用户名合法'

```

当然也可以这样：
```python
def username_check2():
    username = input('输入一个用户名')
    
    for i in range(len(username)):
        if seq_search(username[i],';!~'):
            return '用户名不合法'
    return '用户名合法'
```

这里都是多次调用我们之前写好的`seq_search(s,a)`。

<h4>2. 二分查找</h4>
上述的顺序查找看起来简单，技术含量不高，但对于
<h4></h4>

