查找排序一锅端
==========================
查找(searching)和排序(sorting)是算法的大头，这当中的大部分内容理解起来不难，但真要动手写起来，可能会有这样那样的细节问题。而且感觉除非经常和算法打交道，否则过段时间就很容易忘记具体细节，所以这里尝试着通过例子把要点总结起来。既希望是一个实践性比较强的教程，也是自己的一个备忘录。

这篇笔记会用Python，原因有几个。一来自己习惯Python，二来Python天生好懂，三来这里有个在线的Python解释器：http://repl.it/languages/Python/ 可以零安装零配置零折腾地开始写Python，方便到令人发指。而由于Python本身就有点像伪代码，所以习惯用C或者其它语言的朋友应该也不会感到隔阂。

Python由于太过方便，本身自带了很多查找和排序的功能，所以这个例程会适时地禁用某些东西（比如，总不能直接调用sort()来写一个快速排序吧）。这些会在各个例子里注明，也因此会使得一些代码看起来不那么Pythonic或者解法是sub-optimal。

按照我的其它笔记的模式，从几个例子开始讲起，从最简单的开始说。谨慎建议对于下面的例子，无论看起来多简单，或者用Python，或者用上你熟悉的语言，动手自己写一下，相信会有不一样的发现。

<h4>1. 顺序查找</h4>

**例1** 给定一个整数s和一个整数数组a，判断s是否在a中。（注：不能用Python自带的`if s in a`）

既然没有注明a有什么特性，我们就只能假定它是一个很随机的数组。要判断s是否在a中，我们能做的，也就是逐个访问a中的元素并和s比较。一旦找到，返回`True`，a遍历完了还没找到，则返回`False`。这个过程实现起来非常简单：

```python
def seq_search(s, a):
    for i in range(len(a)):
        if s == a[i]:
            return True
    return False
```
给几个测试例子
```python
a = [13,42,3,4,7,5,6]
s = 7
print seq_search(s,a)

a2 = [10,25,3,4,780,5,6]
s = 70
print seq_search(s,a2)
```

如无意外的话，会输出：
```python
True
False
```

如果要算它的时间复杂度也简单，各种情况下，复杂度是这样的：


| 情况 | 最好 | 最坏 | 平均 |
| :-----: |:--------:| :-----:| :---:|
| 找到了 | 1 | n | n/2 |
| 没找到 | n | n | n |

用`Big-O`来表示，就是复杂度是`O(n)`。对于没找到的情况，数组总是要遍历一次的。而对于元素在数组中的情况，则要分运气好坏，或许第一个就中了，或许最后一个才是，平均而言，则是`n/2`。

**例2** 注册网站账号时，用户名常常要符合某些要求，比如不能含有英文的`;!~`这三个字符。写一个函数，读入用户输出的用户名，返回“用户名合法”或者“用户名不合法”。

一个直观的解法是这样：

```python
def username_check():
    username = input('输入一个用户名')
    
    for s in ';!~':
        if seq_search(s,username):
           return '用户名不合法'
    return '用户名合法'

```

当然也可以这样：
```python
def username_check2():
    username = input('输入一个用户名')
    
    for i in range(len(username)):
        if seq_search(username[i],';!~'):
            return '用户名不合法'
    return '用户名合法'
```

这里都是多次调用我们之前写好的`seq_search(s,a)`。

<h4>2. 二分查找</h4>
上述的顺序查找看起来简单，技术含量不高，但对于一般的数组，确实也只能这样查找了。但假如数组本身是排序好的，则在查找的时候会省事一些。想象一下，如果你要在一堆人中找出体重和你一样的人，一般情况下也没有特殊的办法，只能逐个去比，并期望于早一点找出那个人。但假如告诉你，面前的这一堆人已经按体重由轻到重排列好了，那显然我们不会再一个个去比，而是先瞄一眼，看看有哪个人可能体重和你无限接近，然后和他比较。如果你比他重，说明你要找的人在这个人的右边，如果你比他轻，则说明你要找的人在这个人的左边。于是我们就把范围缩小了，下一次的搜索，我们只需要其中一边去找。而对于这半边，我们又可以故伎重演，找一个人，然后再将这半边队列分成两半。

这其实就是二分查找。只不过对于数字，我们通常无法先主观地找出一个“看起来差不多的”，因此我们会习惯性地从队列中间将队列等分劈成两半。

来看一个具体的例子吧。

```python
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，11, 12]
s = 3
```

同样地，我们想知道3是否在数组里。因为我们知道数组已排序好，所以我们可以直接先看数组的中间值。在这里是6。由于`3<6`，我们于是知道了3只可能在数组的左半边。接下来我们只需要在子数组

```
a_sub = [0, 1, 2, 3, 4, 5]
```

里找就可以了。对于`a_sub`，我们也是取中间的那个值，在这里是2（5/2取整，a[2]=2）。于是我们取右半边：

```
a_sub_sub = [3,4,5]
```

再取中间值4。然后再取左半边：

```
a_sub_sub_sub = [3]
```

这时的中间值刚好就是3了。通过不断缩小范围，我们成功地定位到3这个值。

请原谅略不雅观的命名。

二分查找其实就是这样：数组不断裂变成原来的一半，（最坏情况下）最终到只剩一个元素。而运气好的时候，某一次的中间值刚好就等于你要找的那个值。

下面我们写出以上过程的代码。

**例3** 写一个函数实现二分查找来判断整数s是否在升序排列的整数数组a当中。
```python
def binary_search(s,array):
    found = False
    
    # left 和 right定义子数组的边界，一开始搜索的是整个数组
    left = 0
    right = len(array)-1
        
    while left <= right:
        mid = (left+right) //2
        if array[mid] == s:
            return True
        if s < array[mid]:
            # 到左边去找
            right = mid-1
        else:
            # 到右边去找
            left = mid + 1
            
    return False
```

left和right两个变量，定义我们搜索的子数组的边界。一开始我们查找的是整个数组。以后逐次按照上面的步骤，搜索左半边或者右半边。
只要是左边边界比右边边界小或者相等，就说明数组还至少有一个元素，那我们就持续执行这个裂变的循环。如果找到了，就停止搜索，如果在`while`循环里一直找不到，那么最后就返回`False`。

如果你回顾上述过程，会发现每一次进入一个子数组，我们做的事情是一样的：取中间值，然后比较，取左边/右边。于是这个过程也可以用递归来实现。

如果对递归没有概念的话，可以先看看下面的例子。有接触过递归的朋友就可以果断跳过啦。

**例4** 写一个函数对1-100之间的整数求和。

非递归的解法
```python
def cal_sum(num):
    sum = 0
    for i in range(1,num+1):
        sum += i
    return sum
```

上面的求和方法非常直观，从1到100做一个循环。而用递归的思想来解决是这样的：对1-100求和，其实等于是100加上前99个的和(sum99)，而前99个的和，又等于99+sum98，如此反复。把这个过程表示出来其实就是：

```
sum(i) = i + sum(i-1)
```

因此1-100求和的递归解法可以是：

```python
def cal_sum(i):
    if i == 1:
        return 1
    return i + cal_sum(i-1)
```

是不是看起来更简洁，我们一开始想知道`cal_sum(100)`，通过递归，我们转而去求解`cal_sum(99)`，`cal_sum(99)`又会去调用`cal_sum(98)`。那么到哪里是个头呢？

一个递归函数，必须有一个终止的条件，不然的话就等于是一级一级爬向无底深渊。在上述这个函数里，我们的终止条件就是假如`i==1`，则不再继续递归，而是返回1。

明白了递归的基础知识，我们就可以将二分查找用递归来实现了。如下所示（慎重建议自己先写一遍）：

```python
def binary_search_rec(s,array):
    
    if len(array) == 0:
        # 数组已被掏空
        return False
            
    mid = (len(array)-1) //2
    
    if array[mid] == s:
        # 找到啦
        return True
    elif s < array[mid]:
        # 要找的人在左边
        return binary_search_rec(s, array[:mid])
    else:
        # 要找的人在右边
        return binary_search_rec(s, array[mid+1:])
```

使用递归，要注意终止递归的条件是什么，在这里，如果数组已经是空了，则表示没找到，不再递归，返回`False`，如果找到，也是直接返回，不再折腾子数组了。要注意递归函数被调用时，前面要加`return`。这是因为这里的递归就好像一层一层进入一个深渊去寻找宝藏，而一旦找到，不能简单地满足于在深渊里喊一声“我找到了”，而是要逐层传递回来，直到地面上的人（第一级函数）也收到了信息。


<h4></h4>

