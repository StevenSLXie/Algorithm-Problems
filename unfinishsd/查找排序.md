查找排序一锅端
==========================
查找(searching)和排序(sorting)是算法的大头，这当中的大部分内容理解起来不难，但真要动手写起来总有这样那样的细节问题。而且感觉除非经常和算法打交道，否则过段时间就很容易忘记（起码我是这样，已是第N次回顾某排序算法了），所以这里先挖个坑，通过例子把要点总结起来。既希望是一个实践性比较强的教程，也是自己的一个备忘录。

这篇笔记会用Python，原因有几个。一来自己习惯Python，二来Python天生好懂，三来这里有个在线的Python解释器：http://repl.it/languages/Python/ 可以零安装零配置零折腾地开始写Python，方便到令人发指。

Python由于太过方便，本身自带了很多查找和排序的功能，所以这个例程会适时地禁用某些东西（比如，总不能直接调用sort()来写一个快速排序吧）。这些会在各个例子里注明，也因此会使得一些代码看起来不那么Pythonic或者解法是sub-optimal。

按照我的其它笔记的模式，从几个例子开始讲起，从最简单的开始说。谨慎建议对于下面的例子，无论看起来多简单，或者用Python，或者用上你熟悉的语言，动手自己写一下，相信会有不一样的发现。

<h4>1. 顺序查找</h4>

**例1** 给定一个整数s和一个整数数组a，判断s是否在a中。（注：不能用Python自带的`if s in a`）

```python
def seq_search(s, a):
    for i in range(len(a)):
        if s == a[i]:
            return True
    return False
```
给几个测试例子
```python
a = [13,42,3,4,7,5,6]
s = 7
print seq_search(s,a)

a2 = [10,25,3,4,780,5,6]
s = 70
print seq_search(s,a)
```

如无意外的话，会输出：
```python
True
False
```

这个例子异常简单，无非是遍历一个数组，看能不能找到s,找到了就停止搜索，并返回真，如果转了一圈没结果，就返回假。如果要算它的复杂度也简单，各种情况下，复杂度是这样的：


| 情况 | 最好 | 最坏 | 平均 |
| :-----: |:--------:| :-----:| :---:|
| 找到了 | 1 | n | n/2 |
| 没找到 | n | n | n |

用`Big-O`来表示，就是复杂度是`O(n)`。对于没找到的情况，数组总是要遍历一次的。而对于元素在数组中的情况，则要分运气好坏，或许第一个就中了，或许最后一个才是。

**例2** 注册网站账号时，用户名常常要符合某些要求，比如不能含有英文的`;!~`这三个字符。写一个函数，读入用户输出的用户名，返回“用户名合法”或者“用户名不合法”。

一个直观的解法是这样：

```python
def username_check():
    username = input('输入一个用户名')
    
    for s in ';!~':
        if seq_search(s,username):
           return '用户名不合法'
    return '用户名合法'

```

当然也可以这样：
```python
def username_check2():
    username = input('输入一个用户名')
    
    for i in range(len(username)):
        if seq_search(username[i],';!~'):
            return '用户名不合法'
    return '用户名合法'
```

这里都是多次调用我们之前写好的`seq_search(s,a)`。

<h4>2. 二分查找</h4>
上述的顺序查找看起来简单，技术含量不高，但对于一般的数组，确实也只能这样查找了。但假如数组本身是排序好的，则在查找的时候会省事一些。想象一下，如果你要在一堆人中找出体重和你一样的人，一般情况下也没有特殊的办法，只能逐个去比，并期望于早一点找出那个人。但假如告诉你，面前的这一堆人已经按体重由轻到重排列好了，那显然我们不会再一个个去比，而是先瞄一眼，看看有哪个人可能体重和你无限接近，然后和他比较。如果你比他重，说明你要找的人在这个人的右边，如果你比他轻，则说明你要找的人在这个人的左边。于是我们就把范围缩小了，下一次的搜索，我们只需要其中一边去找。而对于这半边，我们又可以故伎重演，找一个人，然后再将这半边队列分成两半。

这其实就是二分查找。只不过对于数字，我们通常无法先主观地找出一个“看起来差不多的”，因此我们会习惯性地从队列中间将队列等分劈成两半。

来看一个具体的例子吧。

```python
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，11, 12]
s = 3
```

同样地，我们想知道3是否在数组里。因为我们知道数组已排序好，所以我们可以直接先看数组的中间值。在这里是6。由于`3<6`，我们于是知道了3只可能在数组的左半边。接下来我们只需要在子数组

```
a_sub = [0, 1, 2, 3, 4, 5]
```

里找就可以了。对于`a_sub`，我们也是取中间的那个值，在这里是2（5/2取整，a[2]=2）。于是我们取右半边：

```
a_sub_sub = [3,4,5]
```

再取中间值4。然后再取左半边：

```
a_sub_sub_sub = [3]
```

这时的中间值刚好就是3了。通过不断缩小范围，我们成功地定位到3这个值。

请原谅略不雅观的命名。

二分查找其实就是这样：数组不断裂变成原来的一半，（最坏情况下）最终到只剩一个元素。而运气好的时候，某一次的中间值刚好就等于你要找的那个值。

下面我们写出以上过程的代码。

**例3** 写一个函数实现二分查找来判断整数s是否在升序排列的整数数组a当中。
```python
def binary_search(s,a):
    found = False
    
    left = 0
    right = len(a)-1
        
    while left <= right:
        mid = (left+right) //2
        if a[mid] == s:
            return True
        if s < a[mid]:
            # 到左边去找
            right = mid-1
        else:
            # 到右边去找
            left = mid + 1
            
    return False
```

left和right两个变量，定义我们搜索的子数组的边界。一开始我们查找的是整个数组。以后逐次按照上面的步骤，搜索左半边或者右半边。
只要是左边边界比右边边界小或者相等，就说明数组还至少有一个元素，那我们就持续执行这个裂变的循环。

```python
def binary_search_rec(s,a):
    
    if len(a) == 0:
        return False
            
    mid = (len(a)-1) //2
    
    if a[mid] == s:
        return True
    elif s < a[mid]:
        return binary_search_rec(s, a[:mid])
    else:
        return binary_search_rec(s, a[mid+1:])
```


<h4></h4>

