哈希查找
=============
<h4>1. 有没有不笨的方法？</h4>
这一节是<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95.md">顺序查找和二分法</a>的延续。本节内容相对独立，如果你只想了解哈希表和哈希查找，只读这一节就可以了。如果想对查找(searching)算法有个系统的了解，推荐先读前面一节。

前面我们介绍过，用顺序查找的方法来确认一个没有排序好的数组中某个元素是否存在，其时间复杂度为`O(n)`。基本上近似于暴力查找了，没有特别的技巧可言，具体的时间视乎运气，但平均而言，和数组的大小是呈线性关系。而如果数组已排序好，我们可以用二分查找，其时间复杂度为`O(log(n))`。但排序本身也是需要成本的。后面几节我们会了解到，排序是一个相当昂贵的过程。因此假如仅仅是出于方便查找的目的而将数组排序一遍，是非常不划算的。

那么有没有一种查找方法，既不要求数组排序好，又能达到很高的查找效率呢？

如题目所示，这种方法是存在的。

前面我们讲的两种查找，假如给定一个任意值，比如说整数4，那么它是可能存在于数组的任意一个位置的。比如对于一个长度为8的数组`a[8]`，4这个值可能不存在，也可能存储在`a[0]`~`a[7]`之间的任意一个位置。这就给我们的查找带来了难度：我们事先不知道它可能在哪，因此才需要采用各种笨方法去枚举、试探、缩小范围。

而这就给我们提供了一个新的思路：如果我们能在一个数值和它的可能存储的位置之间建立关系，那么当我们要找某个数值的时候，只需要扫一眼那些可能的位置有没有就可以了。如果没有，那就说明那个元素不在数组中。通过这种方法，我们就可以完成查找，而不必去遍历整个数组。

举一个最简单的例子：假设我们有一个大小为5的数组`a[5]`用来存储整数，一开始数组是空的。

这时候进来一个新的数值，38，需要储存。这一次我们并不按照先来后到的规则将其放在`a[0]`，而是我们事先约定一个规则：进来的数值存储的位置等于这个数除以5的余数。`38%5=3`。因此我们把38放在`a[3]`。

稍后又来了几个数，分别是`21 15 4 22`，我们按照对5取余这个规则，分别将它们放在`a[1] a[0] a[4] a[2]`。

存储任务完成。

要查找怎么办呢？假如说我们要看4是否在数组里，这回我们不必遍历整个数组了。我们知道每个数存储的位置等于其除以5的余数，因此，我们只需要按照这个规则去`a[4]`那里看一下就可以了。有就是有，没有就是没有。时间复杂度，请注意，是`O(1)`！这是说，在理想情况下，无论数组多大，由于我们知道了存储的规则，我们可以轻车熟路直接去敲某**一个**对应的门，只打开这个门我们就可以判断出结果。这个过程的时间损耗是恒定的，与数组大小无关。

以上便是一个最简单的哈希表(hash table)。其中`x%5`就是它的哈希函数，通过哈希函数，我们将每一个进来的数值映射到它该去的位置。这就给我们的查找带来极大的方便：既然我们知道了它该去的位置，那么只要去这个位置看一下就可以了。

以上是一个理想的简陋的哈希表。你可能已经发现很多问题了：

如果进来两个数，除以5的余数是相等的，比如`4`和`9`，这个时候如何分配房间？

除以5是否是心血来潮，为何不除以6？

......

嗯，便捷不是没有代价的。选择了一种`O(1)`的方式，也就要打包承担它带来的种种问题。

<h4>2. 哈希函数</h4>

上述的哈希函数的最大的问题，是会引起冲突(collision)。当两个数对5的余数相等时，它们就要争同一个位置了。因此，如何使得每一个进来的数都能映射到一个独一无二的位置，是设计哈希函数的一个大问题。

一个可能的解决方案，是我们把取余的除数设成很大，这样就一定程度避免冲突了。设想如果把除数设为10000000，那么10000000以内的整数对其取余，都可以获得一个unique的值，都会分配到不同的房间，就不会起冲突了。

但是代价是，你要相应地准备10000000个房间。这对内存的挑战是非常大的，嗯即使不大，看起来也是很傻的。除非我们的元素很多，否则你可想而知这个内存的利用率是极低的。





