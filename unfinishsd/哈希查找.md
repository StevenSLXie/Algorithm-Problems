哈希查找
=============
<h4>1. 有没有不笨的方法？</h4>
这一节是<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/%E7%AE%80%E6%98%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%B3%95.md">顺序查找和二分法</a>的延续。本节内容相对独立，如果你只想了解哈希表和哈希查找，只读这一节就可以了。如果想对查找(searching)算法有个系统的了解，推荐先读前面一节。

这一篇的前三节都是基础的介绍，没有具体的算法题，如果对这部分知识已经一定了解，可以直接跳到第四部分。

前面我们介绍过，用顺序查找的方法来确认一个没有排序好的数组中某个元素是否存在，其时间复杂度为`O(n)`。基本上近似于暴力查找了，没有特别的技巧可言，具体的时间视乎运气，但平均而言，和数组的大小是呈线性关系。而如果数组已排序好，我们可以用二分查找，其时间复杂度为`O(log(n))`。但排序本身也是需要成本的。后面几节我们会了解到，排序是一个相当昂贵的过程。因此假如仅仅是出于方便查找的目的而将数组排序一遍，是非常不划算的。

那么有没有一种查找方法，既不要求数组排序好，又能达到很高的查找效率呢？

如题目所示，这种方法是存在的。

前面我们讲的两种查找，假如给定一个任意值，比如说整数4，那么它是可能存在于数组的任意一个位置的。比如对于一个长度为8的数组`a[8]`，4这个值可能不存在，也可能存储在`a[0]`~`a[7]`之间的任意一个位置。这就给我们的查找带来了难度：我们事先不知道它可能在哪，因此才需要采用各种笨方法去枚举、试探、缩小范围。

而这就给我们提供了一个新的思路：如果我们能在一个数值和它的可能存储的位置之间建立关系，那么当我们要找某个数值的时候，只需要扫一眼那些可能的位置有没有就可以了。如果没有，那就说明那个元素不在数组中。通过这种方法，我们就可以完成查找，而不必去遍历整个数组。

举一个最简单的例子：假设我们有一个大小为5的数组`a[5]`用来存储整数，一开始数组是空的。

这时候进来一个新的数值，38，需要储存。这一次我们并不按照先来后到的规则将其放在`a[0]`，而是我们事先约定一个规则：进来的数值存储的位置等于这个数除以5的余数。`38%5=3`。因此我们把38放在`a[3]`。

稍后又来了几个数，分别是`21 15 4 22`，我们按照对5取余这个规则，分别将它们放在`a[1] a[0] a[4] a[2]`。

存储任务完成。

要查找怎么办呢？假如说我们要看4是否在数组里，这回我们不必遍历整个数组了。我们知道每个数存储的位置等于其除以5的余数，因此，我们只需要按照这个规则去`a[4]`那里看一下就可以了。有就是有，没有就是没有。时间复杂度，请注意，是`O(1)`！这是说，在理想情况下，无论数组多大，由于我们知道了存储的规则，我们可以轻车熟路直接去敲某**一个**对应的门，只打开这个门我们就可以判断出结果。这个过程的时间损耗是恒定的，与数组大小无关。

以上便是一个最简单的哈希表(hash table)。其中`x%5`就是它的哈希函数，通过哈希函数，我们将每一个进来的数值映射到它该去的位置。这就给我们的查找带来极大的方便：既然我们知道了它该去的位置，那么只要去这个位置看一下就可以了。

以上是一个理想的简陋的哈希表。你可能已经发现很多问题了：

如果进来两个数，除以5的余数是相等的，比如`4`和`9`，这个时候如何分配房间？

除以5是否是心血来潮，为何不除以6？

......

嗯，便捷不是没有代价的。选择了一种`O(1)`的方式，也就要打包承担它带来的种种问题。

<h4>2. 哈希函数</h4>

上述的哈希函数的最大的问题，是会引起冲突(collision)。当两个数对5的余数相等时，它们就要争同一个位置了。因此，如何使得每一个进来的数都能映射到一个独一无二的位置，是设计哈希函数的一个大问题。

一个可能的解决方案，是我们把取余的除数设成很大，这样就一定程度避免冲突了。设想如果把除数设为10000000，那么10000000以内的整数对其取余，都可以获得一个unique的值，都会分配到不同的房间，就不会起冲突了。

但是代价是，你要相应地准备10000000个房间。这对内存的挑战是非常大的。除非我们的元素很多，否则你可想而知这个内存的利用率是极低的。

另一种方法是一个大数进行拆解，比如我们要存储一个电话号码135-234-232-10。我们可以把它按照三位一组的方式拆开，然后求和：`135+234+232+10=611`。这时假如数组大小是12，那么余数就是11了。

另外的一个常用的方法，是所谓中位平方法(mid-square)。假定我们要存储的数是35，则先求它的平方`35^2=1225`，取中间两位，就得到22，然后再根据数组的大小取余数。

如果我们存储的不是整数，而是，比如字符，那么也可以先通过获取ASCII码的方法获取其数值，然后再设计哈希函数。

总之，设计哈希函数有非常多的常用方法，但没有系统性的一劳永逸的方法。这里面的要点是：

<ul>
<li>尽量避免冲突</li>
<li>尽量提高空间的利用率</li>
<li>要根据存储对象的性质来设计不同的哈希函数；比如，如果我们存储的数都是5的倍数（比如网球小局的比分，那么用取余的方法就不恰当）</li>
</ul>

一些哈希函数的设计可以参考一下<a href="http://en.wikipedia.org/wiki/Hash_function">这里</a>。

<h4>3. 化解冲突</h4>
基本上无论哈希函数设计得多么巧妙，冲突某种程度上总是不能避免的。那么，真的出现了冲突了怎么办？

如果数组已满，每个位置上都有人了，那么当然别无他法。这个即使是一个一般数组也是这样，这里不作讨论。

要考虑的情况是，如果数组还有空位，那么很自然的选择是给新元素找一个次优的位置。

问题是如何找？

我们用`empty`来表示数组某个空位还没人。假设对7取余，某个数组目前是这样的：
```
a[7] = [35, empty, empty, 3, 11, 19, 34];
```

如果我们要插入一个新元素14，这时候由于余数是0，按理是要放在第一位，但由于35已经在那里。我们要另找一个位置。

<h5>3.1 开放定址(Open Addressing)</h5>

一个方法是就近存储，如果余数为0的位置已经有人，则优先存到余数为1的地方，如果还是不行，就存到下一个位置，以此类推。这个方法叫Linear probing。

这个方法的优点是简单，但潜在的问题是，假如某一个位置的冲突的值非常多，除了最先占的那一个，其它元素都要顺延。注意，这个linear probing是有副作用的。像上面的例子，7存到`a[1]`，也使得那些取余为1的数要另找位置，这就可能带来一个连锁反应：在`a[0]`的这个区块附近，所有的数字都不在他们该在的位置。

一个化解方法是，找空位的时候，与其每次移动一个位置，不如移动多一点，确保整个数组都能平衡分布。这样就不会纠集在某个角落（学名叫clustering）。所以，与其加一，我们也可以加三，加五。这个过程表达起来就是：

```
new_position = (original_positon + offset) % array_size
```

`offset`就是我们每次加的值，如果一次不行就接着加，直到找到空位。这里要注意，我们要保证数组的每一个位置都有被访问的机会，不然有些空位永远都不会被用到，其实就使得空间的利用率降低。一个简单的办法，是保证数组的大小是一个素数(质数)。

另一个方法是与其设定一个固定的`offset`，我们可以改变这个数值，比如，一开始按加一的方法来找空位，如果不行，就加4，再不行就加9，16，25...

<h5>3.2 链式定址</h5>

另一类处理冲突的方法，












